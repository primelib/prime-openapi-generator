{# @pebvariable name="t" type="io.github.primelib.primecodegen.core.domain.template.NitroGeneratorData" #}
{# @pebvariable name="cfg" type="io.github.primelib.primecodegen.javafeign.config.JavaFeignGeneratorConfig" #}
{% include "./licenseInfo.peb" %}
package {{ t.additionalProperties.get("invokerPackage") }};

{% include "./import.peb" with {"t": t, "imports": t.api.imports} %}
import {{ t.apiPackage }}.{{ t.mainClassName }}Api;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.json.JsonMapper;
import feign.Feign;
import feign.Logger;
import feign.jackson.JacksonDecoder;
import feign.jackson.JacksonEncoder;
import feign.micrometer.MicrometerCapability;
import feign.okhttp.OkHttpClient;
import feign.reactive.ReactorFeign;
import feign.reactive.RxJavaFeign;
import feign.slf4j.Slf4jLogger;
import io.github.resilience4j.bulkhead.BulkheadRegistry;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.feign.FeignDecorators;
import io.github.resilience4j.feign.Resilience4jFeign;
import io.github.resilience4j.micrometer.tagged.TaggedBulkheadMetrics;
import io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetrics;
import io.github.resilience4j.micrometer.tagged.TaggedRateLimiterMetrics;
import io.github.resilience4j.micrometer.tagged.TaggedRetryMetrics;
import io.github.resilience4j.ratelimiter.RateLimiterRegistry;
import io.github.resilience4j.retry.RetryRegistry;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import io.reactivex.Flowable;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.lang.reflect.Method;

import java.util.function.Consumer;

{# Information #}
@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)
@Slf4j
@Generated(value = "{{ t.generatorClass }}"{% if not cfg.hideGenerationTimestamp %}, date = "{{ t.generatorDate }}"{% endif %})
public class {{ t.mainClassName }}Factory {
    private static final ObjectMapper MAPPER = JsonMapper.builder()
            .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
            .propertyNamingStrategy(PropertyNamingStrategies.LOWER_CAMEL_CASE)
            .configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)
            .build();

    public static <T> T build(Consumer<{{ t.mainClassName }}FactorySpec<T>> spec) {
        {{ t.mainClassName }}FactorySpec<T> config = new {{ t.mainClassName }}FactorySpec<>(spec);

        if (config.api().isInterface()) {
            return buildClient(spec);
        } else {
            switch (detectVariant(config.api())) {
                case "reactor":
                    try {
                        {{ t.mainClassName }}ReactorApi api = buildClient(s -> {
                            s.api({{ t.mainClassName }}ReactorApi.class);
                            s.applySpec(config);
                        });
                        return config.api().getConstructor({{ t.mainClassName }}ReactorApi.class).newInstance(api);
                    } catch (Exception e) {
                        throw new IllegalArgumentException("api must have a constructor with one parameter of type {{ t.mainClassName }}ReactorApi");
                    }
                case "rxjava":
                    try {
                        {{ t.mainClassName }}RxJavaApi api = buildClient(s -> {
                            s.api({{ t.mainClassName }}RxJavaApi.class);
                            s.applySpec(config);
                        });
                        return config.api().getConstructor({{ t.mainClassName }}RxJavaApi.class).newInstance(api);
                    } catch (Exception e) {
                        throw new IllegalArgumentException("api must have a constructor with one parameter of type {{ t.mainClassName }}RxJavaApi");
                    }
                default:
                    try {
                        {{ t.mainClassName }}Api api = buildClient(s -> {
                            s.api({{ t.mainClassName }}Api.class);
                            s.applySpec(config);
                        });
                        return config.api().getConstructor({{ t.mainClassName }}Api.class).newInstance(api);
                    } catch (Exception e) {
                        throw new IllegalArgumentException("api must have a constructor with one parameter of type {{ t.mainClassName }}Api");
                    }
            }
        }
    }

    public static {{ t.mainClassName }}Api build() {
        return build(spec -> spec.api({{ t.mainClassName }}Api.class));
    }

    private static <T> T buildClient(Consumer<{{ t.mainClassName }}FactorySpec<T>> spec) {
        {{ t.mainClassName }}FactorySpec<T> config = new {{ t.mainClassName }}FactorySpec<>(spec);

        // builder
        Feign.Builder builder;
        switch (detectVariant(config.api())) {
            case "reactor":
                builder = ReactorFeign.builder();
                break;
            case "rxjava":
                builder = RxJavaFeign.builder();
                break;
            default:
                // registries
                BulkheadRegistry bulkheadRegistry = BulkheadRegistry.ofDefaults();
                RateLimiterRegistry rateLimiterRegistry = RateLimiterRegistry.ofDefaults();
                CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.ofDefaults();
                RetryRegistry retryRegistry = RetryRegistry.ofDefaults();

                // decorators
                FeignDecorators decorators = FeignDecorators.builder()
                        .withBulkhead(bulkheadRegistry.bulkhead(config.backendName()))
                        .withRateLimiter(rateLimiterRegistry.rateLimiter(config.backendName()))
                        .withCircuitBreaker(circuitBreakerRegistry.circuitBreaker(config.backendName()))
                        .withRetry(retryRegistry.retry(config.backendName()))
                        .build();

                // metrics
                TaggedBulkheadMetrics.ofBulkheadRegistry(bulkheadRegistry).bindTo(config.meterRegistry());
                TaggedRateLimiterMetrics.ofRateLimiterRegistry(rateLimiterRegistry).bindTo(config.meterRegistry());
                TaggedCircuitBreakerMetrics.ofCircuitBreakerRegistry(circuitBreakerRegistry).bindTo(config.meterRegistry());
                TaggedRetryMetrics.ofRetryRegistry(retryRegistry).bindTo(config.meterRegistry());

                // builder
                builder = Resilience4jFeign.builder(decorators);
        }

        // feign client
        return builder
                .client(new OkHttpClient())
                .encoder(new JacksonEncoder(MAPPER))
                .decoder(new JacksonDecoder(MAPPER))
                .logger(new Slf4jLogger())
                .logLevel(Logger.Level.NONE)
                .addCapability(new MicrometerCapability(config.meterRegistry()))
                .target(config.api(), config.baseUrl());
    }

    @NotNull
    private static <T> String detectVariant(Class<T> clazz) {
        Method[] methods = clazz.getDeclaredMethods();

        for (Method method : methods) {
            if (method.getReturnType().isAssignableFrom(Mono.class) || method.getReturnType().isAssignableFrom(Flux.class)) {
                return "reactor";
            } else if (method.getReturnType().isAssignableFrom(Flowable.class)) {
                return "rxjava";
            }
        }

        return "default";
    }
}
